Total duration: 19.5217s
File: c:\Users\Job de Vogel\OneDrive\Documenten\TU Delft\Master Thesis\Dataset_pipeline\dataset\load_3dbag\sensors.py
File duration: 14.5185s (74.37%)
Line #|      Hits|         Time| Time per hit|      %|Source code
------+----------+-------------+-------------+-------+-----------
     1|         0|            0|            0|  0.00%|import Rhino.Geometry as rg
     2|         0|            0|            0|  0.00%|import Rhino
     3|         0|            0|            0|  0.00%|import System
     4|         0|            0|            0|  0.00%|import time
     5|         0|            0|            0|  0.00%|import warnings
     6|         0|            0|            0|  0.00%|import sys
     7|         0|            0|            0|  0.00%|import rhino3dm
     8|         0|            0|            0|  0.00%|import pprofile
     9|         0|            0|            0|  0.00%|import math
    10|         0|            0|            0|  0.00%|import numpy as np
    11|         0|            0|            0|  0.00%|import copy
    12|         0|            0|            0|  0.00%|
    13|         0|            0|            0|  0.00%|'''
    14|         0|            0|            0|  0.00%|Exception line 245 at index 11
    15|         0|            0|            0|  0.00%|'''
    16|         0|            0|            0|  0.00%|
    17|         3|            0|            0|  0.00%|def join_meshes(meshes):
    18|         3|            0|            0|  0.00%|    joined_meshes = rg.Mesh()
    19|       139|            0|            0|  0.00%|    for mesh in meshes:
    20|       136|     0.027499|  0.000202198|  0.14%|        joined_meshes.Append(mesh)
(call)|       272|   0.00584173|   2.1477e-05|  0.03%|# <string>:4 __init__
    21|         0|            0|            0|  0.00%|
    22|         3|            0|            0|  0.00%|    return joined_meshes
    23|         0|            0|            0|  0.00%|
    24|         0|            0|            0|  0.00%|#8.94%
    25|         0|            0|            0|  0.00%|def get_face_vertices(face, mesh):
    26|         0|            0|            0|  0.00%|    # vertex_0 = rg.Point3d(mesh.Vertices[face.A].X, mesh.Vertices[face.A].Y, mesh.Vertices[face.A].Z)
    27|         0|            0|            0|  0.00%|    # vertex_1 = rg.Point3d(mesh.Vertices[face.B].X, mesh.Vertices[face.B].Y, mesh.Vertices[face.B].Z)
    28|         0|            0|            0|  0.00%|    # vertex_2 = rg.Point3d(mesh.Vertices[face.C].X, mesh.Vertices[face.C].Y, mesh.Vertices[face.C].Z)
    29|         0|            0|            0|  0.00%|    # vertex_3 = rg.Point3d(mesh.Vertices[face.D].X, mesh.Vertices[face.D].Y, mesh.Vertices[face.D].Z)
    30|         0|            0|            0|  0.00%|
    31|         0|            0|            0|  0.00%|    vertices = [rg.Point3d(mesh.Vertices[vertex].X, mesh.Vertices[vertex].Y, mesh.Vertices[vertex].Z)
    32|         0|            0|            0|  0.00%|                for vertex in (face.A, face.B, face.C, face.D)]
    33|         0|            0|            0|  0.00%|
    34|         0|            0|            0|  0.00%|    if face.IsQuad:
    35|         0|            0|            0|  0.00%|        return vertices[:4]
    36|         0|            0|            0|  0.00%|    else:
    37|         0|            0|            0|  0.00%|        return vertices[:3]
    38|         0|            0|            0|  0.00%|
    39|         1|            0|            0|  0.00%|def delete_invalid_sensors(mesh, sensors, normals, minimum_angle = 0.017, minimum_area=0.0001):
    40|         0|            0|            0|  0.00%|
    41|     11176|     0.392691|   3.5137e-05|  2.01%|    face_vertices = [list(mesh.Faces.GetFaceVertices(i)[1:]) for i in range(len(mesh.Faces))]
(call)|         1|     0.392691|     0.392691|  2.01%|# c:\Users\Job de Vogel\OneDrive\Documenten\TU Delft\Master Thesis\Dataset_pipeline\dataset\load_3dbag\sensors.py:41 <listcomp>
    42|         1|            0|            0|  0.00%|    copied_vertices = copy.copy(face_vertices)
(call)|         1|            0|            0|  0.00%|# C:\Users\Job de Vogel\.conda\envs\graduation\lib\copy.py:66 copy
    43|         0|            0|            0|  0.00%|
    44|     11174|      0.14409|  1.28951e-05|  0.74%|    for i, (face, normal) in enumerate(zip(mesh.Faces, mesh.FaceNormals)):
    45|         0|            0|            0|  0.00%|        # vertices = get_face_vertices(face, mesh)
    46|     78211|      4.47157|  5.71732e-05| 22.91%|        vertices = [rg.Point3d(vertex) for vertex in copied_vertices[i]]
(call)|    268152|      3.22939|  1.20431e-05| 16.54%|# <string>:4 __init__
(call)|     11173|       7.5751|  0.000677983| 38.80%|# c:\Users\Job de Vogel\OneDrive\Documenten\TU Delft\Master Thesis\Dataset_pipeline\dataset\load_3dbag\sensors.py:46 <listcomp>
    47|         0|            0|            0|  0.00%|
    48|     11173|    0.0606873|   5.4316e-06|  0.31%|        if face.IsTriangle:
    49|      3545|    0.0638144|  1.80012e-05|  0.33%|            triangle = rg.Triangle3d(vertices[0], vertices[1], vertices[2])
    50|      3545|    0.0406196|  1.14583e-05|  0.21%|            min_angle = min([triangle.AngleA, triangle.AngleB, triangle.AngleC])
    51|         0|            0|            0|  0.00%|
    52|      3545|    0.0105762|  2.98343e-06|  0.05%|            if min_angle < minimum_angle:
    53|      1035|   0.00253487|  2.44915e-06|  0.01%|                sensors[i] = None
    54|      1035|   0.00198555|  1.91841e-06|  0.01%|                normals[i] = None
    55|      2510|    0.0149767|  5.96683e-06|  0.08%|            elif triangle.Area < minimum_area:
    56|       178|  0.000996113|  5.59614e-06|  0.01%|                sensors[i] = None
    57|       178|            0|            0|  0.00%|                normals[i] = None
    58|         0|            0|            0|  0.00%|
    59|         0|            0|            0|  0.00%|#        elif face.IsQuad:
    60|         0|            0|            0|  0.00%|#            rectangle = rg.Rectangle3d(rg.Plane.WorldXY, vertices[0], vertices[2])
    61|         0|            0|            0|  0.00%|#
    62|         0|            0|            0|  0.00%|#            triangle_1 = rg.Triangle3d(vertices[0], vertices[1], vertices[2])
    63|         0|            0|            0|  0.00%|#            triangle_2 = rg.Triangle3d(vertices[2], vertices[3], vertices[0])
    64|         0|            0|            0|  0.00%|#
    65|         0|            0|            0|  0.00%|#            min_angle = min([triangle_1.AngleA, triangle_1.AngleB, triangle_1.AngleC, triangle_2.AngleA, triangle_2.AngleB, triangle_2.AngleC])
    66|         0|            0|            0|  0.00%|#
    67|         0|            0|            0|  0.00%|#            if min_angle < minimum_angle:
    68|         0|            0|            0|  0.00%|#                sensors[i] = None
    69|         0|            0|            0|  0.00%|#                normals[i] = None
    70|         0|            0|            0|  0.00%|#            elif triangle_1.Area < minimum_area or triangle_2.Area < minimum_area:
    71|         0|            0|            0|  0.00%|#                sensors[i] = None
    72|         0|            0|            0|  0.00%|#                normals[i] = None
    73|         0|            0|            0|  0.00%|
    74|         0|            0|            0|  0.00%|
    75|         1|            0|            0|  0.00%|    return sensors, normals
    76|         0|            0|            0|  0.00%|
    77|         0|            0|            0|  0.00%|# def compute_centroids(mesh, offset):
    78|         0|            0|            0|  0.00%|#     vectors = [rg.Vector3f.Multiply(mesh.FaceNormals[i], offset) for i in xrange(mesh.Faces.Count)]
    79|         0|            0|            0|  0.00%|#     centroids = [mesh.Faces.GetFaceCenter(i) for i in xrange(mesh.Faces.Count)]
    80|         0|            0|            0|  0.00%|
    81|         0|            0|            0|  0.00%|#     for centroid, vec in zip(centroids, vectors):
    82|         0|            0|            0|  0.00%|#         centroid.Transform(rg.Transform.Translation(vec))
    83|         0|            0|            0|  0.00%|
    84|         0|            0|            0|  0.00%|#     return centroids, vectors
    85|         0|            0|            0|  0.00%|
    86|         0|            0|            0|  0.00%|# Make faster with Numpy, using arrays of vectors
    87|         0|            0|            0|  0.00%|def perpendicular_wall_vectors(vector):
    88|         0|            0|            0|  0.00%|    z_vector = rg.Vector3f(0,0,1)
    89|         0|            0|            0|  0.00%|    vec1 = rg.Vector3f.CrossProduct(vector, z_vector)
    90|         0|            0|            0|  0.00%|    vec2 = -vec1
    91|         0|            0|            0|  0.00%|
    92|         0|            0|            0|  0.00%|    return (vec1, vec2)
    93|         0|            0|            0|  0.00%|
    94|        47|            0|            0|  0.00%|def _to_numpy(points, vectors, offset):
    95|     31779|     0.191535|  6.02709e-06|  0.98%|    np_points = np.array([[point.X, point.Y, point.Z] for point in points])
(call)|        47|     0.162373|   0.00345475|  0.83%|# c:\Users\Job de Vogel\OneDrive\Documenten\TU Delft\Master Thesis\Dataset_pipeline\dataset\load_3dbag\sensors.py:95 <listcomp>
    96|     31779|     0.281296|  8.85165e-06|  1.44%|    np_vectors = np.array([[vector.X, vector.Y, vector.Z] for vector in vectors]) * offset
(call)|        47|     0.256738|   0.00546251|  1.32%|# c:\Users\Job de Vogel\OneDrive\Documenten\TU Delft\Master Thesis\Dataset_pipeline\dataset\load_3dbag\sensors.py:96 <listcomp>
    97|         0|            0|            0|  0.00%|
    98|        47|   0.00100136|  2.13055e-05|  0.01%|    new_points = np_points + np_vectors
    99|     31779|     0.878421|  2.76416e-05|  4.50%|    rg_points = [rg.Point3d(*point) for point in new_points]
(call)|        47|     0.877424|    0.0186686|  4.49%|# c:\Users\Job de Vogel\OneDrive\Documenten\TU Delft\Master Thesis\Dataset_pipeline\dataset\load_3dbag\sensors.py:99 <listcomp>
   100|         0|            0|            0|  0.00%|
   101|        47|            0|            0|  0.00%|    return rg_points
   102|         0|            0|            0|  0.00%|
   103|         0|            0|            0|  0.00%|#11.99%
   104|        47|  0.000997543|  2.12243e-05|  0.01%|def offset_points(points, vectors, offset):
   105|         0|            0|            0|  0.00%|    # offset_vectors = [rg.Vector3f.Multiply(vec, offset) for vec in vectors]
   106|         0|            0|            0|  0.00%|    # points = [point + offset_vec for point, offset_vec in zip(points, offset_vectors)]
   107|         0|            0|            0|  0.00%|
   108|        47|            0|            0|  0.00%|    points = _to_numpy(points, vectors, offset)
(call)|        47|      1.35225|    0.0287714|  6.93%|# c:\Users\Job de Vogel\OneDrive\Documenten\TU Delft\Master Thesis\Dataset_pipeline\dataset\load_3dbag\sensors.py:94 _to_numpy
   109|         0|            0|            0|  0.00%|
   110|        47|            0|            0|  0.00%|    return points
   111|         0|            0|            0|  0.00%|
   112|     19136|    0.0720623|   3.7658e-06|  0.37%|def is_above_mesh(point, meshes, ray_vector=rg.Vector3d(0,0,-1)):
   113|     19136|    0.0632613|  3.30588e-06|  0.32%|    intersects = False
   114|     19136|      1.03712|  5.41973e-05|  5.31%|    ray = rg.Ray3d(point, ray_vector)
(call)|     38272|      0.54726|  1.42992e-05|  2.80%|# <string>:4 __init__
   115|         0|            0|            0|  0.00%|
   116|     30218|     0.124967|  4.13551e-06|  0.64%|    for mesh in meshes:
   117|         0|            0|            0|  0.00%|        #11.28%
   118|     19136|     0.588901|  3.07745e-05|  3.02%|        if rg.Intersect.Intersection.MeshRay(mesh, ray) > 0:
   119|      8054|    0.0343931|  4.27031e-06|  0.18%|            intersects = True
   120|      8054|    0.0135438|  1.68163e-06|  0.07%|            break
   121|         0|            0|            0|  0.00%|
   122|     19136|    0.0522697|  2.73149e-06|  0.27%|    return intersects
   123|         0|            0|            0|  0.00%|
   124|      5533|    0.0161462|  2.91816e-06|  0.08%|def roof_ray_intersection(point, roofs, face_height, grid_size, offset):
   125|      5533|     0.183982|  3.32517e-05|  0.94%|    upwards_vector = rg.Vector3d(0,0,1)
   126|      5533|     0.342993|  6.19903e-05|  1.76%|    ray = rg.Ray3d(point, upwards_vector)
(call)|     11066|     0.178663|  1.61453e-05|  0.92%|# <string>:4 __init__
   127|         0|            0|            0|  0.00%|
   128|      5533|    0.0239851|  4.33493e-06|  0.12%|    success = False
   129|     10782|    0.0341742|  3.16956e-06|  0.18%|    for roof in roofs:
   130|         0|            0|            0|  0.00%|        # 9.80%
   131|      5533|      0.16146|  2.91813e-05|  0.83%|        distance = rg.Intersect.Intersection.MeshRay(roof, ray)
   132|         0|            0|            0|  0.00%|
   133|      5533|    0.0306211|  5.53426e-06|  0.16%|        if 0 < distance < 0.5 * face_height:
   134|       284|    0.0609055|  0.000214456|  0.31%|            point += upwards_vector * distance + rg.Vector3d(0,0,offset)
(call)|      1704|     0.029438|  1.72758e-05|  0.15%|# <string>:4 __init__
   135|       284|   0.00100017|  3.52171e-06|  0.01%|            success = True
   136|       284|            0|            0|  0.00%|            break
   137|         0|            0|            0|  0.00%|
   138|      5533|    0.0164936|  2.98094e-06|  0.08%|    return success, point
   139|         0|            0|            0|  0.00%|
   140|      5249|    0.0190139|  3.62238e-06|  0.10%|def wall_ray_intersection(point, normal, walls, grid_size, offset, tolerance=0.1):
   141|      5249|     0.143947|  2.74237e-05|  0.74%|    upwards_vector = rg.Vector3f(0,0,1)
   142|         0|            0|            0|  0.00%|
   143|      5249|     0.143275|  2.72956e-05|  0.73%|    left_vector = rg.Vector3f.CrossProduct(normal, upwards_vector)
   144|      5249|     0.150349|  2.86433e-05|  0.77%|    right_vector = -left_vector
   145|         0|            0|            0|  0.00%|
   146|      5249|      0.75997|  0.000144784|  3.89%|    left_ray = rg.Ray3d(point, rg.Vector3d(left_vector))
(call)|     31494|     0.492667|  1.56432e-05|  2.52%|# <string>:4 __init__
   147|      5249|     0.715317|  0.000136277|  3.66%|    right_ray = rg.Ray3d(point, rg.Vector3d(right_vector))
(call)|     31494|     0.489036|  1.55279e-05|  2.51%|# <string>:4 __init__
   148|         0|            0|            0|  0.00%|
   149|      5249|    0.0267351|  5.09336e-06|  0.14%|    success = False
   150|     10362|    0.0371878|  3.58886e-06|  0.19%|    for wall in walls:
   151|         0|            0|            0|  0.00%|        # 20%
   152|      5249|     0.224066|  4.26873e-05|  1.15%|        left_distance = rg.Intersect.Intersection.MeshRay(wall, left_ray)
   153|      5249|     0.199168|   3.7944e-05|  1.02%|        right_distance = rg.Intersect.Intersection.MeshRay(wall, right_ray)
   154|         0|            0|            0|  0.00%|
   155|      5249|    0.0271075|  5.16431e-06|  0.14%|        if 0 < left_distance < 0.5 * grid_size - tolerance:
   156|        61|            0|            0|  0.00%|            if left_distance < right_distance:
   157|        61|    0.0111215|   0.00018232|  0.06%|                left_vector = rg.Vector3d.Multiply(rg.Vector3d(left_vector), left_distance + offset)
(call)|       488|    0.0163431|    3.349e-05|  0.08%|# <string>:4 __init__
   158|        61|   0.00449967|  7.37651e-05|  0.02%|                point += left_vector
(call)|       244|  0.000997782|  4.08927e-06|  0.01%|# <string>:4 __init__
   159|        61|  0.000995874|  1.63258e-05|  0.01%|                success = True
   160|        61|            0|            0|  0.00%|                break
   161|         0|            0|            0|  0.00%|
   162|      5188|    0.0235622|  4.54167e-06|  0.12%|        elif 0 < right_distance < 0.5 * grid_size - tolerance:
   163|        75|            0|            0|  0.00%|            if right_distance < left_distance:
   164|        75|    0.0104318|   0.00013909|  0.05%|                right_vector = rg.Vector3d.Multiply(rg.Vector3d(right_vector), right_distance + offset)
(call)|       600|   0.00556469|  9.27448e-06|  0.03%|# <string>:4 __init__
   165|        75|   0.00395989|  5.27986e-05|  0.02%|                point += right_vector
(call)|       300|    0.0044744|  1.49147e-05|  0.02%|# <string>:4 __init__
   166|        75|            0|            0|  0.00%|                success = True
   167|        75|  0.000999212|  1.33228e-05|  0.01%|                break
   168|         0|            0|            0|  0.00%|
   169|      5249|    0.0191457|   3.6475e-06|  0.10%|    return success, point
   170|         0|            0|            0|  0.00%|
   171|         1|            0|            0|  0.00%|def compute(ground, roofs, walls, building_heights, grid_size, offset, quad_only=False):
   172|         1|            0|            0|  0.00%|    sensorpoints = []
   173|         1|            0|            0|  0.00%|    normals = []
   174|         0|            0|            0|  0.00%|
   175|         1|    0.0261102|    0.0261102|  0.13%|    ground_normals = list(ground.FaceNormals)
   176|     11176|     0.438197|  3.92088e-05|  2.24%|    ground_centroids = [ground.Faces.GetFaceCenter(System.Int32(i)) for i in range(ground.Faces.Count)]
(call)|         1|     0.438197|     0.438197|  2.24%|# c:\Users\Job de Vogel\OneDrive\Documenten\TU Delft\Master Thesis\Dataset_pipeline\dataset\load_3dbag\sensors.py:176 <listcomp>
   177|         0|            0|            0|  0.00%|
   178|         0|            0|            0|  0.00%|    # 8.73%
   179|         1|            0|            0|  0.00%|    start = time.time()
   180|         1|   0.00561547|   0.00561547|  0.03%|    ground_centroids = offset_points(ground_centroids, ground_normals, offset)
(call)|         1|     0.430869|     0.430869|  2.21%|# c:\Users\Job de Vogel\OneDrive\Documenten\TU Delft\Master Thesis\Dataset_pipeline\dataset\load_3dbag\sensors.py:104 offset_points
   181|         1|            0|            0|  0.00%|    p1 = time.time() - start
   182|         0|            0|            0|  0.00%|
   183|         0|            0|            0|  0.00%|    # 10.17%
   184|         1|            0|            0|  0.00%|    start = time.time()
   185|         1|    0.0400686|    0.0400686|  0.21%|    ground_centroids, ground_normals = delete_invalid_sensors(ground, ground_centroids, ground_normals)
(call)|         1|      8.43393|      8.43393| 43.20%|# c:\Users\Job de Vogel\OneDrive\Documenten\TU Delft\Master Thesis\Dataset_pipeline\dataset\load_3dbag\sensors.py:39 delete_invalid_sensors
   186|         1|            0|            0|  0.00%|    p2 = time.time() - start
   187|         0|            0|            0|  0.00%|
   188|         1|            0|            0|  0.00%|    joined_roofs = join_meshes(roofs)
(call)|         1|     0.013344|     0.013344|  0.07%|# c:\Users\Job de Vogel\OneDrive\Documenten\TU Delft\Master Thesis\Dataset_pipeline\dataset\load_3dbag\sensors.py:17 join_meshes
   189|         1|            0|            0|  0.00%|    roof_normals = joined_roofs.FaceNormals
   190|      6881|     0.223866|  3.25339e-05|  1.15%|    roof_centroids = [joined_roofs.Faces.GetFaceCenter(System.Int32(i)) for i in range(joined_roofs.Faces.Count)]
(call)|         1|     0.223866|     0.223866|  1.15%|# c:\Users\Job de Vogel\OneDrive\Documenten\TU Delft\Master Thesis\Dataset_pipeline\dataset\load_3dbag\sensors.py:190 <listcomp>
   191|         0|            0|            0|  0.00%|
   192|         0|            0|            0|  0.00%|    # 6.45%
   193|         1|            0|            0|  0.00%|    start = time.time()
   194|         1|   0.00299239|   0.00299239|  0.02%|    roof_centroids = offset_points(roof_centroids, roof_normals, offset)
(call)|         1|     0.290636|     0.290636|  1.49%|# c:\Users\Job de Vogel\OneDrive\Documenten\TU Delft\Master Thesis\Dataset_pipeline\dataset\load_3dbag\sensors.py:104 offset_points
   195|         1|            0|            0|  0.00%|    p3 = time.time() - start
   196|         0|            0|            0|  0.00%|
   197|         1|            0|            0|  0.00%|    sensorpoints.extend(ground_centroids)
   198|         1|            0|            0|  0.00%|    normals.extend(ground_normals)
   199|         1|            0|            0|  0.00%|    sensorpoints.extend(roof_centroids)
   200|         1|    0.0160244|    0.0160244|  0.08%|    normals.extend(roof_normals)
   201|         0|            0|            0|  0.00%|
   202|         1|            0|            0|  0.00%|    meshes = [ground] + roofs
   203|         1|            0|            0|  0.00%|    joined_meshes = join_meshes(meshes)
(call)|         1|    0.0115075|    0.0115075|  0.06%|# c:\Users\Job de Vogel\OneDrive\Documenten\TU Delft\Master Thesis\Dataset_pipeline\dataset\load_3dbag\sensors.py:17 join_meshes
   204|         0|            0|            0|  0.00%|
   205|         1|            0|            0|  0.00%|    joined_walls = join_meshes(walls)
(call)|         1|   0.00848913|   0.00848913|  0.04%|# c:\Users\Job de Vogel\OneDrive\Documenten\TU Delft\Master Thesis\Dataset_pipeline\dataset\load_3dbag\sensors.py:17 join_meshes
   206|         0|            0|            0|  0.00%|
   207|         1|            0|            0|  0.00%|    start = time.time()
   208|        46|            0|            0|  0.00%|    for i, (wall, height) in enumerate(zip(walls, building_heights)):
   209|        45|   0.00218463|  4.85473e-05|  0.01%|        wall.FaceNormals.ComputeFaceNormals()
   210|         0|            0|            0|  0.00%|
   211|        45|            0|            0|  0.00%|        wall_normals = wall.FaceNormals
   212|     13722|     0.366143|  2.66829e-05|  1.88%|        wall_sensors = [wall.Faces.GetFaceCenter(j) for j in range(wall.Faces.Count)]
(call)|        45|     0.359064|   0.00797919|  1.84%|# c:\Users\Job de Vogel\OneDrive\Documenten\TU Delft\Master Thesis\Dataset_pipeline\dataset\load_3dbag\sensors.py:212 <listcomp>
   213|        45|    0.0111499|  0.000247775|  0.06%|        wall_sensors = offset_points(wall_sensors, wall_normals, offset)
(call)|        45|     0.631747|    0.0140388|  3.24%|# c:\Users\Job de Vogel\OneDrive\Documenten\TU Delft\Master Thesis\Dataset_pipeline\dataset\load_3dbag\sensors.py:104 offset_points
   214|         0|            0|            0|  0.00%|
   215|        45|            0|            0|  0.00%|        face_height = height / int(math.ceil(height / grid_size))
   216|         0|            0|            0|  0.00%|
   217|     13632|     0.165901|  1.21699e-05|  0.85%|        for point, normal in zip(wall_sensors, wall_normals):
   218|         0|            0|            0|  0.00%|            # 15.88%
   219|     13587|     0.200346|  1.47454e-05|  1.03%|            if is_above_mesh(point, [joined_meshes]):
(call)|     13587|      1.78798|  0.000131595|  9.16%|# c:\Users\Job de Vogel\OneDrive\Documenten\TU Delft\Master Thesis\Dataset_pipeline\dataset\load_3dbag\sensors.py:112 is_above_mesh
   220|      8038|    0.0458324|  5.70197e-06|  0.23%|                sensorpoints.append(point)
   221|      8038|    0.0535383|  6.66065e-06|  0.27%|                normals.append(normal)
   222|         0|            0|            0|  0.00%|            # Check if the sensorpoints are under the corresponding walls' roof (because of splitting error)
   223|      5549|     0.231743|   4.1763e-05|  1.19%|            elif is_above_mesh(point, [meshes[i+1]], ray_vector=rg.Vector3d(0,0,1)):
(call)|      5549|     0.745796|  0.000134402|  3.82%|# c:\Users\Job de Vogel\OneDrive\Documenten\TU Delft\Master Thesis\Dataset_pipeline\dataset\load_3dbag\sensors.py:112 is_above_mesh
   224|        16|            0|            0|  0.00%|                sensorpoints.append(point)
   225|        16|            0|            0|  0.00%|                normals.append(normal)
   226|         0|            0|            0|  0.00%|            else:
   227|         0|            0|            0|  0.00%|                # Try to move the sensorpoint to close roof + offset
   228|      5533|    0.0770054|  1.39175e-05|  0.39%|                success, point = roof_ray_intersection(point, [joined_roofs], face_height, grid_size, offset)
(call)|      5533|      1.07986|  0.000195168|  5.53%|# c:\Users\Job de Vogel\OneDrive\Documenten\TU Delft\Master Thesis\Dataset_pipeline\dataset\load_3dbag\sensors.py:124 roof_ray_intersection
   229|         0|            0|            0|  0.00%|
   230|      5533|    0.0393839|    7.118e-06|  0.20%|                if not success:
   231|         0|            0|            0|  0.00%|                    # Try to move the sensorpoint to close wall + offset
   232|         0|            0|            0|  0.00%|
   233|         0|            0|            0|  0.00%|                    # 30.56%
   234|      5249|    0.0961659|  1.83208e-05|  0.49%|                    success, point = wall_ray_intersection(point, normal, [joined_walls], grid_size, offset)
(call)|      5249|      3.52994|  0.000672497| 18.08%|# c:\Users\Job de Vogel\OneDrive\Documenten\TU Delft\Master Thesis\Dataset_pipeline\dataset\load_3dbag\sensors.py:140 wall_ray_intersection
   235|         0|            0|            0|  0.00%|
   236|      5249|    0.0222578|  4.24039e-06|  0.11%|                    if not success:
   237|      5113|    0.0220127|  4.30524e-06|  0.11%|                        point = None
   238|      5113|    0.0216315|  4.23068e-06|  0.11%|                        normal = None
   239|         0|            0|            0|  0.00%|
   240|      5533|     0.039072|  7.06164e-06|  0.20%|                sensorpoints.append(point)
   241|      5533|    0.0298038|  5.38654e-06|  0.15%|                normals.append(normal)
   242|         1|            0|            0|  0.00%|    p4 = time.time() - start
   243|         0|            0|            0|  0.00%|
   244|         1|            0|            0|  0.00%|    start = time.time()
   245|         1|            0|            0|  0.00%|    meshes = [ground] + roofs + walls
   246|         1|            0|            0|  0.00%|    joined_mesh = rg.Mesh()
   247|        92|            0|            0|  0.00%|    for mesh in meshes:
   248|        91|    0.0312612|   0.00034353|  0.16%|        joined_mesh.Append(mesh)
(call)|       182|   0.00199628|  1.09686e-05|  0.01%|# <string>:4 __init__
   249|         0|            0|            0|  0.00%|
   250|         1|            0|            0|  0.00%|    if quad_only:
   251|         0|            0|            0|  0.00%|        horizontal_mesh = rg.Mesh()
   252|         0|            0|            0|  0.00%|        for mesh in meshes:
   253|         0|            0|            0|  0.00%|            horizontal_mesh.Append(mesh)
   254|         0|            0|            0|  0.00%|
   255|         0|            0|            0|  0.00%|        new_sensorpoints = []
   256|         0|            0|            0|  0.00%|        new_normals = []
   257|         0|            0|            0|  0.00%|        for face, point, normal in zip(horizontal_mesh.Faces, sensorpoints, normals):
   258|         0|            0|            0|  0.00%|            if not face.IsTriangle:
   259|         0|            0|            0|  0.00%|                new_sensorpoints.append(point)
   260|         0|            0|            0|  0.00%|                new_normals.append(normal)
   261|         0|            0|            0|  0.00%|            else:
   262|         0|            0|            0|  0.00%|                new_sensorpoints.append(None)
   263|         0|            0|            0|  0.00%|                new_normals.append(None)
   264|         0|            0|            0|  0.00%|
   265|         0|            0|            0|  0.00%|        sensorpoints = new_sensorpoints
   266|         0|            0|            0|  0.00%|        normals = new_normals
   267|         1|            0|            0|  0.00%|    p5 = time.time() - start
   268|         0|            0|            0|  0.00%|
   269|         1|   0.00102472|   0.00102472|  0.01%|    print(p1)
   270|         1|            0|            0|  0.00%|    print(p2)
   271|         1|            0|            0|  0.00%|    print(p3)
   272|         1|            0|            0|  0.00%|    print(p4)
   273|         1|            0|            0|  0.00%|    print(p5)
   274|         0|            0|            0|  0.00%|
   275|         1|            0|            0|  0.00%|    return sensorpoints, normals
   276|         0|            0|            0|  0.00%|
   277|         1|            0|            0|  0.00%|def filter_sensors(sensorpoints, normals):
   278|         1|            0|            0|  0.00%|    filtered_points = []
   279|         1|            0|            0|  0.00%|    filtered_normals = []
   280|         1|            0|            0|  0.00%|    pointmap = []
   281|         0|            0|            0|  0.00%|
   282|     31639|    0.0669951|  2.11749e-06|  0.34%|    for point, normal in zip(sensorpoints, normals):
   283|     31638|     0.079555|  2.51454e-06|  0.41%|        if point is not None:
   284|     25312|    0.0524604|  2.07255e-06|  0.27%|            filtered_points.append(point)
   285|     25312|    0.0585029|  2.31127e-06|  0.30%|            filtered_normals.append(normal)
   286|     25312|    0.0678744|  2.68151e-06|  0.35%|            pointmap.append(True)
   287|         0|            0|            0|  0.00%|        else:
   288|      6326|    0.0193927|  3.06556e-06|  0.10%|            pointmap.append(False)
   289|         0|            0|            0|  0.00%|
   290|         1|            0|            0|  0.00%|    return filtered_points, filtered_normals, pointmap
   291|         0|            0|            0|  0.00%|
   292|         0|            0|            0|  0.00%|
   293|         0|            0|            0|  0.00%|
File: <string>
File duration: 5.00167s (25.62%)
Line #|      Hits|         Time| Time per hit|      %|Source code
------+----------+-------------+-------------+-------+-----------
     1|         0|            0|            0|  0.00%|
     2|         0|            0|            0|  0.00%|
     3|         0|            0|            0|  0.00%|
     4|    384268|     0.859615|  2.23702e-06|  4.40%|
     5|    384268|     0.927927|  2.41479e-06|  4.75%|
     6|    384268|     0.848955|  2.20928e-06|  4.35%|
     7|    384268|     0.802961|  2.08959e-06|  4.11%|
     8|    384268|     0.795338|  2.06975e-06|  4.07%|
     9|    384268|     0.766874|  1.99567e-06|  3.93%|
File: C:\Users\Job de Vogel\.conda\envs\graduation\lib\copy.py
File duration: 0s (0.00%)
Line #|      Hits|         Time| Time per hit|      %|Source code
------+----------+-------------+-------------+-------+-----------
     1|         0|            0|            0|  0.00%|"""Generic (shallow and deep) copying operations.
     2|         0|            0|            0|  0.00%|
     3|         0|            0|            0|  0.00%|Interface summary:
     4|         0|            0|            0|  0.00%|
     5|         0|            0|            0|  0.00%|        import copy
     6|         0|            0|            0|  0.00%|
     7|         0|            0|            0|  0.00%|        x = copy.copy(y)        # make a shallow copy of y
     8|         0|            0|            0|  0.00%|        x = copy.deepcopy(y)    # make a deep copy of y
     9|         0|            0|            0|  0.00%|
    10|         0|            0|            0|  0.00%|For module specific errors, copy.Error is raised.
    11|         0|            0|            0|  0.00%|
    12|         0|            0|            0|  0.00%|The difference between shallow and deep copying is only relevant for
    13|         0|            0|            0|  0.00%|compound objects (objects that contain other objects, like lists or
    14|         0|            0|            0|  0.00%|class instances).
    15|         0|            0|            0|  0.00%|
    16|         0|            0|            0|  0.00%|- A shallow copy constructs a new compound object and then (to the
    17|         0|            0|            0|  0.00%|  extent possible) inserts *the same objects* into it that the
    18|         0|            0|            0|  0.00%|  original contains.
    19|         0|            0|            0|  0.00%|
    20|         0|            0|            0|  0.00%|- A deep copy constructs a new compound object and then, recursively,
    21|         0|            0|            0|  0.00%|  inserts *copies* into it of the objects found in the original.
    22|         0|            0|            0|  0.00%|
    23|         0|            0|            0|  0.00%|Two problems often exist with deep copy operations that don't exist
    24|         0|            0|            0|  0.00%|with shallow copy operations:
    25|         0|            0|            0|  0.00%|
    26|         0|            0|            0|  0.00%| a) recursive objects (compound objects that, directly or indirectly,
    27|         0|            0|            0|  0.00%|    contain a reference to themselves) may cause a recursive loop
    28|         0|            0|            0|  0.00%|
    29|         0|            0|            0|  0.00%| b) because deep copy copies *everything* it may copy too much, e.g.
    30|         0|            0|            0|  0.00%|    administrative data structures that should be shared even between
    31|         0|            0|            0|  0.00%|    copies
    32|         0|            0|            0|  0.00%|
    33|         0|            0|            0|  0.00%|Python's deep copy operation avoids these problems by:
    34|         0|            0|            0|  0.00%|
    35|         0|            0|            0|  0.00%| a) keeping a table of objects already copied during the current
    36|         0|            0|            0|  0.00%|    copying pass
    37|         0|            0|            0|  0.00%|
    38|         0|            0|            0|  0.00%| b) letting user-defined classes override the copying operation or the
    39|         0|            0|            0|  0.00%|    set of components copied
    40|         0|            0|            0|  0.00%|
    41|         0|            0|            0|  0.00%|This version does not copy types like module, class, function, method,
    42|         0|            0|            0|  0.00%|nor stack trace, stack frame, nor file, socket, window, nor array, nor
    43|         0|            0|            0|  0.00%|any similar types.
    44|         0|            0|            0|  0.00%|
    45|         0|            0|            0|  0.00%|Classes can use the same interfaces to control copying that they use
    46|         0|            0|            0|  0.00%|to control pickling: they can define methods called __getinitargs__(),
    47|         0|            0|            0|  0.00%|__getstate__() and __setstate__().  See the documentation for module
    48|         0|            0|            0|  0.00%|"pickle" for information on these methods.
    49|         0|            0|            0|  0.00%|"""
    50|         0|            0|            0|  0.00%|
    51|         0|            0|            0|  0.00%|import types
    52|         0|            0|            0|  0.00%|import weakref
    53|         0|            0|            0|  0.00%|from copyreg import dispatch_table
    54|         0|            0|            0|  0.00%|
    55|         0|            0|            0|  0.00%|class Error(Exception):
    56|         0|            0|            0|  0.00%|    pass
    57|         0|            0|            0|  0.00%|error = Error   # backward compatibility
    58|         0|            0|            0|  0.00%|
    59|         0|            0|            0|  0.00%|try:
    60|         0|            0|            0|  0.00%|    from org.python.core import PyStringMap
    61|         0|            0|            0|  0.00%|except ImportError:
    62|         0|            0|            0|  0.00%|    PyStringMap = None
    63|         0|            0|            0|  0.00%|
    64|         0|            0|            0|  0.00%|__all__ = ["Error", "copy", "deepcopy"]
    65|         0|            0|            0|  0.00%|
    66|         1|            0|            0|  0.00%|def copy(x):
    67|         0|            0|            0|  0.00%|    """Shallow copy operation on arbitrary Python objects.
    68|         0|            0|            0|  0.00%|
    69|         0|            0|            0|  0.00%|    See the module's __doc__ string for more info.
    70|         0|            0|            0|  0.00%|    """
    71|         0|            0|            0|  0.00%|
    72|         1|            0|            0|  0.00%|    cls = type(x)
    73|         0|            0|            0|  0.00%|
    74|         1|            0|            0|  0.00%|    copier = _copy_dispatch.get(cls)
    75|         1|            0|            0|  0.00%|    if copier:
    76|         1|            0|            0|  0.00%|        return copier(x)
    77|         0|            0|            0|  0.00%|
    78|         0|            0|            0|  0.00%|    try:
    79|         0|            0|            0|  0.00%|        issc = issubclass(cls, type)
    80|         0|            0|            0|  0.00%|    except TypeError: # cls is not a class
    81|         0|            0|            0|  0.00%|        issc = False
    82|         0|            0|            0|  0.00%|    if issc:
    83|         0|            0|            0|  0.00%|        # treat it as a regular class:
    84|         0|            0|            0|  0.00%|        return _copy_immutable(x)
    85|         0|            0|            0|  0.00%|
    86|         0|            0|            0|  0.00%|    copier = getattr(cls, "__copy__", None)
    87|         0|            0|            0|  0.00%|    if copier:
    88|         0|            0|            0|  0.00%|        return copier(x)
    89|         0|            0|            0|  0.00%|
    90|         0|            0|            0|  0.00%|    reductor = dispatch_table.get(cls)
    91|         0|            0|            0|  0.00%|    if reductor:
    92|         0|            0|            0|  0.00%|        rv = reductor(x)
    93|         0|            0|            0|  0.00%|    else:
    94|         0|            0|            0|  0.00%|        reductor = getattr(x, "__reduce_ex__", None)
    95|         0|            0|            0|  0.00%|        if reductor:
    96|         0|            0|            0|  0.00%|            rv = reductor(4)
    97|         0|            0|            0|  0.00%|        else:
    98|         0|            0|            0|  0.00%|            reductor = getattr(x, "__reduce__", None)
    99|         0|            0|            0|  0.00%|            if reductor:
   100|         0|            0|            0|  0.00%|                rv = reductor()
   101|         0|            0|            0|  0.00%|            else:
   102|         0|            0|            0|  0.00%|                raise Error("un(shallow)copyable object of type %s" % cls)
   103|         0|            0|            0|  0.00%|
   104|         0|            0|            0|  0.00%|    if isinstance(rv, str):
   105|         0|            0|            0|  0.00%|        return x
   106|         0|            0|            0|  0.00%|    return _reconstruct(x, None, *rv)
   107|         0|            0|            0|  0.00%|
   108|         0|            0|            0|  0.00%|
   109|         0|            0|            0|  0.00%|_copy_dispatch = d = {}
   110|         0|            0|            0|  0.00%|
   111|         0|            0|            0|  0.00%|def _copy_immutable(x):
   112|         0|            0|            0|  0.00%|    return x
   113|         0|            0|            0|  0.00%|for t in (type(None), int, float, bool, complex, str, tuple,
   114|         0|            0|            0|  0.00%|          bytes, frozenset, type, range, slice, property,
   115|         0|            0|            0|  0.00%|          types.BuiltinFunctionType, type(Ellipsis), type(NotImplemented),
   116|         0|            0|            0|  0.00%|          types.FunctionType, weakref.ref):
   117|         0|            0|            0|  0.00%|    d[t] = _copy_immutable
   118|         0|            0|            0|  0.00%|t = getattr(types, "CodeType", None)
   119|         0|            0|            0|  0.00%|if t is not None:
   120|         0|            0|            0|  0.00%|    d[t] = _copy_immutable
   121|         0|            0|            0|  0.00%|
   122|         0|            0|            0|  0.00%|d[list] = list.copy
   123|         0|            0|            0|  0.00%|d[dict] = dict.copy
   124|         0|            0|            0|  0.00%|d[set] = set.copy
   125|         0|            0|            0|  0.00%|d[bytearray] = bytearray.copy
   126|         0|            0|            0|  0.00%|
   127|         0|            0|            0|  0.00%|if PyStringMap is not None:
   128|         0|            0|            0|  0.00%|    d[PyStringMap] = PyStringMap.copy
   129|         0|            0|            0|  0.00%|
   130|         0|            0|            0|  0.00%|del d, t
   131|         0|            0|            0|  0.00%|
   132|         0|            0|            0|  0.00%|def deepcopy(x, memo=None, _nil=[]):
   133|         0|            0|            0|  0.00%|    """Deep copy operation on arbitrary Python objects.
   134|         0|            0|            0|  0.00%|
   135|         0|            0|            0|  0.00%|    See the module's __doc__ string for more info.
   136|         0|            0|            0|  0.00%|    """
   137|         0|            0|            0|  0.00%|
   138|         0|            0|            0|  0.00%|    if memo is None:
   139|         0|            0|            0|  0.00%|        memo = {}
   140|         0|            0|            0|  0.00%|
   141|         0|            0|            0|  0.00%|    d = id(x)
   142|         0|            0|            0|  0.00%|    y = memo.get(d, _nil)
   143|         0|            0|            0|  0.00%|    if y is not _nil:
   144|         0|            0|            0|  0.00%|        return y
   145|         0|            0|            0|  0.00%|
   146|         0|            0|            0|  0.00%|    cls = type(x)
   147|         0|            0|            0|  0.00%|
   148|         0|            0|            0|  0.00%|    copier = _deepcopy_dispatch.get(cls)
   149|         0|            0|            0|  0.00%|    if copier:
   150|         0|            0|            0|  0.00%|        y = copier(x, memo)
   151|         0|            0|            0|  0.00%|    else:
   152|         0|            0|            0|  0.00%|        try:
   153|         0|            0|            0|  0.00%|            issc = issubclass(cls, type)
   154|         0|            0|            0|  0.00%|        except TypeError: # cls is not a class (old Boost; see SF #502085)
   155|         0|            0|            0|  0.00%|            issc = 0
   156|         0|            0|            0|  0.00%|        if issc:
   157|         0|            0|            0|  0.00%|            y = _deepcopy_atomic(x, memo)
   158|         0|            0|            0|  0.00%|        else:
   159|         0|            0|            0|  0.00%|            copier = getattr(x, "__deepcopy__", None)
   160|         0|            0|            0|  0.00%|            if copier:
   161|         0|            0|            0|  0.00%|                y = copier(memo)
   162|         0|            0|            0|  0.00%|            else:
   163|         0|            0|            0|  0.00%|                reductor = dispatch_table.get(cls)
   164|         0|            0|            0|  0.00%|                if reductor:
   165|         0|            0|            0|  0.00%|                    rv = reductor(x)
   166|         0|            0|            0|  0.00%|                else:
   167|         0|            0|            0|  0.00%|                    reductor = getattr(x, "__reduce_ex__", None)
   168|         0|            0|            0|  0.00%|                    if reductor:
   169|         0|            0|            0|  0.00%|                        rv = reductor(4)
   170|         0|            0|            0|  0.00%|                    else:
   171|         0|            0|            0|  0.00%|                        reductor = getattr(x, "__reduce__", None)
   172|         0|            0|            0|  0.00%|                        if reductor:
   173|         0|            0|            0|  0.00%|                            rv = reductor()
   174|         0|            0|            0|  0.00%|                        else:
   175|         0|            0|            0|  0.00%|                            raise Error(
   176|         0|            0|            0|  0.00%|                                "un(deep)copyable object of type %s" % cls)
   177|         0|            0|            0|  0.00%|                if isinstance(rv, str):
   178|         0|            0|            0|  0.00%|                    y = x
   179|         0|            0|            0|  0.00%|                else:
   180|         0|            0|            0|  0.00%|                    y = _reconstruct(x, memo, *rv)
   181|         0|            0|            0|  0.00%|
   182|         0|            0|            0|  0.00%|    # If is its own copy, don't memoize.
   183|         0|            0|            0|  0.00%|    if y is not x:
   184|         0|            0|            0|  0.00%|        memo[d] = y
   185|         0|            0|            0|  0.00%|        _keep_alive(x, memo) # Make sure x lives at least as long as d
   186|         0|            0|            0|  0.00%|    return y
   187|         0|            0|            0|  0.00%|
   188|         0|            0|            0|  0.00%|_deepcopy_dispatch = d = {}
   189|         0|            0|            0|  0.00%|
   190|         0|            0|            0|  0.00%|def _deepcopy_atomic(x, memo):
   191|         0|            0|            0|  0.00%|    return x
   192|         0|            0|            0|  0.00%|d[type(None)] = _deepcopy_atomic
   193|         0|            0|            0|  0.00%|d[type(Ellipsis)] = _deepcopy_atomic
   194|         0|            0|            0|  0.00%|d[type(NotImplemented)] = _deepcopy_atomic
   195|         0|            0|            0|  0.00%|d[int] = _deepcopy_atomic
   196|         0|            0|            0|  0.00%|d[float] = _deepcopy_atomic
   197|         0|            0|            0|  0.00%|d[bool] = _deepcopy_atomic
   198|         0|            0|            0|  0.00%|d[complex] = _deepcopy_atomic
   199|         0|            0|            0|  0.00%|d[bytes] = _deepcopy_atomic
   200|         0|            0|            0|  0.00%|d[str] = _deepcopy_atomic
   201|         0|            0|            0|  0.00%|try:
   202|         0|            0|            0|  0.00%|    d[types.CodeType] = _deepcopy_atomic
   203|         0|            0|            0|  0.00%|except AttributeError:
   204|         0|            0|            0|  0.00%|    pass
   205|         0|            0|            0|  0.00%|d[type] = _deepcopy_atomic
   206|         0|            0|            0|  0.00%|d[types.BuiltinFunctionType] = _deepcopy_atomic
   207|         0|            0|            0|  0.00%|d[types.FunctionType] = _deepcopy_atomic
   208|         0|            0|            0|  0.00%|d[weakref.ref] = _deepcopy_atomic
   209|         0|            0|            0|  0.00%|d[property] = _deepcopy_atomic
   210|         0|            0|            0|  0.00%|
   211|         0|            0|            0|  0.00%|def _deepcopy_list(x, memo, deepcopy=deepcopy):
   212|         0|            0|            0|  0.00%|    y = []
   213|         0|            0|            0|  0.00%|    memo[id(x)] = y
   214|         0|            0|            0|  0.00%|    append = y.append
   215|         0|            0|            0|  0.00%|    for a in x:
   216|         0|            0|            0|  0.00%|        append(deepcopy(a, memo))
   217|         0|            0|            0|  0.00%|    return y
   218|         0|            0|            0|  0.00%|d[list] = _deepcopy_list
   219|         0|            0|            0|  0.00%|
   220|         0|            0|            0|  0.00%|def _deepcopy_tuple(x, memo, deepcopy=deepcopy):
   221|         0|            0|            0|  0.00%|    y = [deepcopy(a, memo) for a in x]
   222|         0|            0|            0|  0.00%|    # We're not going to put the tuple in the memo, but it's still important we
   223|         0|            0|            0|  0.00%|    # check for it, in case the tuple contains recursive mutable structures.
   224|         0|            0|            0|  0.00%|    try:
   225|         0|            0|            0|  0.00%|        return memo[id(x)]
   226|         0|            0|            0|  0.00%|    except KeyError:
   227|         0|            0|            0|  0.00%|        pass
   228|         0|            0|            0|  0.00%|    for k, j in zip(x, y):
   229|         0|            0|            0|  0.00%|        if k is not j:
   230|         0|            0|            0|  0.00%|            y = tuple(y)
   231|         0|            0|            0|  0.00%|            break
   232|         0|            0|            0|  0.00%|    else:
   233|         0|            0|            0|  0.00%|        y = x
   234|         0|            0|            0|  0.00%|    return y
   235|         0|            0|            0|  0.00%|d[tuple] = _deepcopy_tuple
   236|         0|            0|            0|  0.00%|
   237|         0|            0|            0|  0.00%|def _deepcopy_dict(x, memo, deepcopy=deepcopy):
   238|         0|            0|            0|  0.00%|    y = {}
   239|         0|            0|            0|  0.00%|    memo[id(x)] = y
   240|         0|            0|            0|  0.00%|    for key, value in x.items():
   241|         0|            0|            0|  0.00%|        y[deepcopy(key, memo)] = deepcopy(value, memo)
   242|         0|            0|            0|  0.00%|    return y
   243|         0|            0|            0|  0.00%|d[dict] = _deepcopy_dict
   244|         0|            0|            0|  0.00%|if PyStringMap is not None:
   245|         0|            0|            0|  0.00%|    d[PyStringMap] = _deepcopy_dict
   246|         0|            0|            0|  0.00%|
   247|         0|            0|            0|  0.00%|def _deepcopy_method(x, memo): # Copy instance methods
   248|         0|            0|            0|  0.00%|    return type(x)(x.__func__, deepcopy(x.__self__, memo))
   249|         0|            0|            0|  0.00%|d[types.MethodType] = _deepcopy_method
   250|         0|            0|            0|  0.00%|
   251|         0|            0|            0|  0.00%|del d
   252|         0|            0|            0|  0.00%|
   253|         0|            0|            0|  0.00%|def _keep_alive(x, memo):
   254|         0|            0|            0|  0.00%|    """Keeps a reference to the object x in the memo.
   255|         0|            0|            0|  0.00%|
   256|         0|            0|            0|  0.00%|    Because we remember objects by their id, we have
   257|         0|            0|            0|  0.00%|    to assure that possibly temporary objects are kept
   258|         0|            0|            0|  0.00%|    alive by referencing them.
   259|         0|            0|            0|  0.00%|    We store a reference at the id of the memo, which should
   260|         0|            0|            0|  0.00%|    normally not be used unless someone tries to deepcopy
   261|         0|            0|            0|  0.00%|    the memo itself...
   262|         0|            0|            0|  0.00%|    """
   263|         0|            0|            0|  0.00%|    try:
   264|         0|            0|            0|  0.00%|        memo[id(memo)].append(x)
   265|         0|            0|            0|  0.00%|    except KeyError:
   266|         0|            0|            0|  0.00%|        # aha, this is the first one :-)
   267|         0|            0|            0|  0.00%|        memo[id(memo)]=[x]
   268|         0|            0|            0|  0.00%|
   269|         0|            0|            0|  0.00%|def _reconstruct(x, memo, func, args,
   270|         0|            0|            0|  0.00%|                 state=None, listiter=None, dictiter=None,
   271|         0|            0|            0|  0.00%|                 deepcopy=deepcopy):
   272|         0|            0|            0|  0.00%|    deep = memo is not None
   273|         0|            0|            0|  0.00%|    if deep and args:
   274|         0|            0|            0|  0.00%|        args = (deepcopy(arg, memo) for arg in args)
   275|         0|            0|            0|  0.00%|    y = func(*args)
   276|         0|            0|            0|  0.00%|    if deep:
   277|         0|            0|            0|  0.00%|        memo[id(x)] = y
   278|         0|            0|            0|  0.00%|
   279|         0|            0|            0|  0.00%|    if state is not None:
   280|         0|            0|            0|  0.00%|        if deep:
   281|         0|            0|            0|  0.00%|            state = deepcopy(state, memo)
   282|         0|            0|            0|  0.00%|        if hasattr(y, '__setstate__'):
   283|         0|            0|            0|  0.00%|            y.__setstate__(state)
   284|         0|            0|            0|  0.00%|        else:
   285|         0|            0|            0|  0.00%|            if isinstance(state, tuple) and len(state) == 2:
   286|         0|            0|            0|  0.00%|                state, slotstate = state
   287|         0|            0|            0|  0.00%|            else:
   288|         0|            0|            0|  0.00%|                slotstate = None
   289|         0|            0|            0|  0.00%|            if state is not None:
   290|         0|            0|            0|  0.00%|                y.__dict__.update(state)
   291|         0|            0|            0|  0.00%|            if slotstate is not None:
   292|         0|            0|            0|  0.00%|                for key, value in slotstate.items():
   293|         0|            0|            0|  0.00%|                    setattr(y, key, value)
   294|         0|            0|            0|  0.00%|
   295|         0|            0|            0|  0.00%|    if listiter is not None:
   296|         0|            0|            0|  0.00%|        if deep:
   297|         0|            0|            0|  0.00%|            for item in listiter:
   298|         0|            0|            0|  0.00%|                item = deepcopy(item, memo)
   299|         0|            0|            0|  0.00%|                y.append(item)
   300|         0|            0|            0|  0.00%|        else:
   301|         0|            0|            0|  0.00%|            for item in listiter:
   302|         0|            0|            0|  0.00%|                y.append(item)
   303|         0|            0|            0|  0.00%|    if dictiter is not None:
   304|         0|            0|            0|  0.00%|        if deep:
   305|         0|            0|            0|  0.00%|            for key, value in dictiter:
   306|         0|            0|            0|  0.00%|                key = deepcopy(key, memo)
   307|         0|            0|            0|  0.00%|                value = deepcopy(value, memo)
   308|         0|            0|            0|  0.00%|                y[key] = value
   309|         0|            0|            0|  0.00%|        else:
   310|         0|            0|            0|  0.00%|            for key, value in dictiter:
   311|         0|            0|            0|  0.00%|                y[key] = value
   312|         0|            0|            0|  0.00%|    return y
   313|         0|            0|            0|  0.00%|
   314|         0|            0|            0|  0.00%|del types, weakref, PyStringMap
File: c:/Users/Job de Vogel/OneDrive/Documenten/TU Delft/Master Thesis/Dataset_pipeline/dataset/main.py
File duration: 0s (0.00%)
Line #|      Hits|         Time| Time per hit|      %|Source code
------+----------+-------------+-------------+-------+-----------
     1|         0|            0|            0|  0.00%|# HERE WE RECEIVE CMD ARGUMENTS
     2|         0|            0|            0|  0.00%|# HERE WE LOAD RHINO INSIDE
     3|         0|            0|            0|  0.00%|# HERE WE RUN ALL SCRIPTS FOR THE DATASET GENERATION
     4|         0|            0|            0|  0.00%|
     5|         0|            0|            0|  0.00%|import rhinoinside
     6|         0|            0|            0|  0.00%|rhinoinside.load()
     7|         0|            0|            0|  0.00%|
     8|         0|            0|            0|  0.00%|# import rhino_inside
     9|         0|            0|            0|  0.00%|
    10|         0|            0|            0|  0.00%|# rhino_inside.load()
    11|         0|            0|            0|  0.00%|
    12|         0|            0|            0|  0.00%|print('Finished loading rhinoinside...')
    13|         0|            0|            0|  0.00%|
    14|         0|            0|            0|  0.00%|import Rhino.Geometry as rg
    15|         0|            0|            0|  0.00%|import System
    16|         0|            0|            0|  0.00%|
    17|         0|            0|            0|  0.00%|import pickle
    18|         0|            0|            0|  0.00%|import pprofile
    19|         0|            0|            0|  0.00%|import time
    20|         0|            0|            0|  0.00%|
    21|         0|            0|            0|  0.00%|from load_3dbag import file, outlines, height, meshing, sensors
    22|         0|            0|            0|  0.00%|# from visualize.mesh import show
    23|         0|            0|            0|  0.00%|from transform import points, model
    24|         0|            0|            0|  0.00%|from input_output import save, load
    25|         0|            0|            0|  0.00%|from simulate import run
    26|         0|            0|            0|  0.00%|
    27|         0|            0|            0|  0.00%|def main():
    28|         0|            0|            0|  0.00%|    _, _, roof_meshes, wall_meshes, _, bbox = file.load("C://Users//Job de Vogel//OneDrive//Documenten//TU Delft//Master Thesis//Dataset_pipeline//3D_BAG_dataset//3dbag_v210908_fd2cee53_lod12_3d_5859.obj")
    29|         0|            0|            0|  0.00%|
    30|         0|            0|            0|  0.00%|    patch_outlines = outlines.generate_outlines_from_bbox(bbox, 100, 58)
    31|         0|            0|            0|  0.00%|    heights = height.generate(roof_meshes)
    32|         0|            0|            0|  0.00%|
    33|         0|            0|            0|  0.00%|    idx = 0
    34|         0|            0|            0|  0.00%|
    35|         0|            0|            0|  0.00%|    patch_outline = patch_outlines[idx]
    36|         0|            0|            0|  0.00%|
    37|         0|            0|            0|  0.00%|    print('Generating outlines...')
    38|         0|            0|            0|  0.00%|    building_outlines, courtyard_outlines, building_heights, FSI_score, envelope_area, building_area = outlines.generate_building_outlines(patch_outline, wall_meshes, heights)
    39|         0|            0|            0|  0.00%|
    40|         0|            0|            0|  0.00%|    grid_size = 1.0
    41|         0|            0|            0|  0.00%|
    42|         0|            0|            0|  0.00%|    print('Meshing walls...')
    43|         0|            0|            0|  0.00%|    walls, wall_outlines = meshing.generate_vertical(building_outlines, courtyard_outlines, building_heights, grid_size)
    44|         0|            0|            0|  0.00%|
    45|         0|            0|            0|  0.00%|    print('Meshing ground and roofs...')
    46|         0|            0|            0|  0.00%|    '''
    47|         0|            0|            0|  0.00%|    RESOLVE: For some reason outlines are converted to nurbscurves here
    48|         0|            0|            0|  0.00%|    '''
    49|         0|            0|            0|  0.00%|    mesh_plane, roofs = meshing.generate_horizontal(patch_outline, building_outlines, courtyard_outlines, building_heights, grid_size)
    50|         0|            0|            0|  0.00%|    # profiler.dump_stats("C://Users//Job de Vogel//Desktop/stats.txt")
    51|         0|            0|            0|  0.00%|
    52|         0|            0|            0|  0.00%|    '''
    53|         0|            0|            0|  0.00%|    SENSORS
    54|         0|            0|            0|  0.00%|    '''
    55|         0|            0|            0|  0.00%|    offset = 0.1
    56|         0|            0|            0|  0.00%|
    57|         0|            0|            0|  0.00%|    profiler = pprofile.Profile()
    58|         0|            0|            0|  0.00%|    with profiler:
    59|         0|            0|            0|  0.00%|        sensorpoints, normals = sensors.compute(mesh_plane, roofs, walls, building_heights, grid_size, offset)
(call)|         1|      19.1754|      19.1754| 98.23%|# c:\Users\Job de Vogel\OneDrive\Documenten\TU Delft\Master Thesis\Dataset_pipeline\dataset\load_3dbag\sensors.py:171 compute
    60|         0|            0|            0|  0.00%|        filtered_points, filtered_normals, pointmap = sensors.filter_sensors(sensorpoints, normals)
(call)|         1|     0.344781|     0.344781|  1.77%|# c:\Users\Job de Vogel\OneDrive\Documenten\TU Delft\Master Thesis\Dataset_pipeline\dataset\load_3dbag\sensors.py:277 filter_sensors
    61|         0|            0|            0|  0.00%|    profiler.dump_stats("./stats/stats_3.txt")
    62|         0|            0|            0|  0.00%|
    63|         0|            0|            0|  0.00%|    array = points.data_to_array(filtered_points, filtered_normals)
    64|         0|            0|            0|  0.00%|
    65|         0|            0|            0|  0.00%|    # save.save_array(array)
    66|         0|            0|            0|  0.00%|    save.save_array_as_list(array)
    67|         0|            0|            0|  0.00%|
    68|         0|            0|            0|  0.00%|    # array = load.load_array('./data/array.npy')
    69|         0|            0|            0|  0.00%|    # List = load.load_array_as_list('./data/list_data.pkl')
    70|         0|            0|            0|  0.00%|
    71|         0|            0|            0|  0.00%|    # roof_mesh = sensors.join_meshes(roofs)
    72|         0|            0|            0|  0.00%|
    73|         0|            0|            0|  0.00%|    # rough_ground_mesh = meshing.remesh_horizontal(mesh_plane)
    74|         0|            0|            0|  0.00%|    # rough_roof_mesh = meshing.remesh_horizontal(roof_mesh)
    75|         0|            0|            0|  0.00%|    # rough_wall_meshes = [meshing.remesh_vertical(outline, height) for outline, height in zip(wall_outlines, building_heights)]
    76|         0|            0|            0|  0.00%|
    77|         0|            0|            0|  0.00%|    # rough_wall_mesh = sensors.join_meshes(rough_wall_meshes)
    78|         0|            0|            0|  0.00%|
    79|         0|            0|            0|  0.00%|    # HB_model = model.generate([rough_ground_mesh], [rough_roof_mesh], [rough_wall_mesh], filtered_points, filtered_normals)
    80|         0|            0|            0|  0.00%|
    81|         0|            0|            0|  0.00%|    # wea = "C:\\Users\\Job de Vogel\\AppData\\Roaming\\ladybug_tools\\weather\\NLD_Amsterdam.062400_IWEC\\NLD_Amsterdam.062400_IWEC.epw"
    82|         0|            0|            0|  0.00%|    # sim_arguments = '-ab 6 -ad 25000 -as 4096 -c 1 -dc 0.75 -dp 512 -dr 3 -ds 0.05 -dt 0.15 -lr 8 -lw 4e-07 -ss 1.0 -st 0.15'
    83|         0|            0|            0|  0.00%|    # results = run.main(HB_model, wea, sim_arguments, pointmap)
    84|         0|            0|            0|  0.00%|
    85|         0|            0|            0|  0.00%|    # print(results)
    86|         0|            0|            0|  0.00%|
    87|         0|            0|            0|  0.00%|    # '''
    88|         0|            0|            0|  0.00%|    # IO
    89|         0|            0|            0|  0.00%|    # '''
    90|         0|            0|            0|  0.00%|    # print('Saving meshes...')
    91|         0|            0|            0|  0.00%|    # mesh_types = ['ground', 'walls', 'roofs']
    92|         0|            0|            0|  0.00%|    # meshes = [mesh_plane, walls, roofs]
    93|         0|            0|            0|  0.00%|    # save.save_mesh_to_json(meshes, mesh_types, 'test_sample', 'C://Users//Job de Vogel//Desktop')
    94|         0|            0|            0|  0.00%|
    95|         0|            0|            0|  0.00%|    # load.load_mesh_from_json('test_sample', 'C://Users//Job de Vogel//Desktop', mesh_types)
    96|         0|            0|            0|  0.00%|
    97|         0|            0|            0|  0.00%|    # '''
    98|         0|            0|            0|  0.00%|    # VISUALIZATION
    99|         0|            0|            0|  0.00%|    # '''
   100|         0|            0|            0|  0.00%|    # triangle_meshes = []
   101|         0|            0|            0|  0.00%|    # triangle_meshes.append(meshing.triangulate_quad(mesh_plane))
   102|         0|            0|            0|  0.00%|    # for roof in roofs:
   103|         0|            0|            0|  0.00%|    #     triangle_meshes.append(meshing.triangulate_quad(roof))
   104|         0|            0|            0|  0.00%|
   105|         0|            0|            0|  0.00%|    # for wall in walls:
   106|         0|            0|            0|  0.00%|    #     triangle_meshes.append(meshing.triangulate_quad(wall))
   107|         0|            0|            0|  0.00%|
   108|         0|            0|            0|  0.00%|    # show(triangle_meshes)
   109|         0|            0|            0|  0.00%|
   110|         0|            0|            0|  0.00%|if __name__ == '__main__':
   111|         0|            0|            0|  0.00%|    main()
   112|         0|            0|            0|  0.00%|
   113|         0|            0|            0|  0.00%|    print('finished')
